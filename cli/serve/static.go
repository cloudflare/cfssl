package serve

import (
	"bytes"
	"compress/gzip"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"sync"
	"time"
)

type escLocalFS struct{}

var escLocal escLocalFS

type escStaticFS struct{}

var escStatic escStaticFS

type escFile struct {
	compressed string
	size       int64
	local      string
	isDir      bool

	data []byte
	once sync.Once
	name string
}

func (escLocalFS) Open(name string) (http.File, error) {
	f, present := escData[path.Clean(name)]
	if !present {
		return nil, os.ErrNotExist
	}
	return os.Open(f.local)
}

func (escStaticFS) prepare(name string) (*escFile, error) {
	f, present := escData[path.Clean(name)]
	if !present {
		return nil, os.ErrNotExist
	}
	var err error
	f.once.Do(func() {
		f.name = path.Base(name)
		if f.size == 0 {
			return
		}
		var gr *gzip.Reader
		gr, err = gzip.NewReader(bytes.NewBufferString(f.compressed))
		if err != nil {
			return
		}
		f.data, err = ioutil.ReadAll(gr)
	})
	if err != nil {
		return nil, err
	}
	return f, nil
}

func (fs escStaticFS) Open(name string) (http.File, error) {
	f, err := fs.prepare(name)
	if err != nil {
		return nil, err
	}
	return f.File()
}

func (f *escFile) File() (http.File, error) {
	type httpFile struct {
		*bytes.Reader
		*escFile
	}
	return &httpFile{
		Reader:  bytes.NewReader(f.data),
		escFile: f,
	}, nil
}

func (f *escFile) Close() error {
	return nil
}

func (f *escFile) Readdir(count int) ([]os.FileInfo, error) {
	return nil, nil
}

func (f *escFile) Stat() (os.FileInfo, error) {
	return f, nil
}

func (f *escFile) Name() string {
	return f.name
}

func (f *escFile) Size() int64 {
	return f.size
}

func (f *escFile) Mode() os.FileMode {
	return 0
}

func (f *escFile) ModTime() time.Time {
	return time.Time{}
}

func (f *escFile) IsDir() bool {
	return f.isDir
}

func (f *escFile) Sys() interface{} {
	return f
}

// FS returns a http.Filesystem for the embedded assets. If useLocal is true,
// the filesystem's contents are instead used.
func FS(useLocal bool) http.FileSystem {
	if useLocal {
		return escLocal
	}
	return escStatic
}

// FSByte returns the named file from the embedded assets. If useLocal is
// true, the filesystem's contents are instead used.
func FSByte(useLocal bool, name string) ([]byte, error) {
	if useLocal {
		f, err := escLocal.Open(name)
		if err != nil {
			return nil, err
		}
		return ioutil.ReadAll(f)
	}
	f, err := escStatic.prepare(name)
	if err != nil {
		return nil, err
	}
	return f.data, nil
}

// FSMustByte is the same as FSByte, but panics if name is not present.
func FSMustByte(useLocal bool, name string) []byte {
	b, err := FSByte(useLocal, name)
	if err != nil {
		panic(err)
	}
	return b
}

// FSString is the string version of FSByte.
func FSString(useLocal bool, name string) (string, error) {
	b, err := FSByte(useLocal, name)
	return string(b), err
}

// FSMustString is the string version of FSMustByte.
func FSMustString(useLocal bool, name string) string {
	return string(FSMustByte(useLocal, name))
}

var escData = map[string]*escFile{

	"/index.html": {
		local: "cli/serve/static/index.html",
		size:  943,
		compressed: "" +
			"\x1f\x8b\b\x00\x00\tn\x88\x00\xff|S\xc1\x8e\xd30\x10\xbd\xf7+\x86\\zj\x86\xd5r@+7\x97B\x01\x81\xc4J]\x0e\x1c\x1d\xdbm\xbc\xebږ=\x81\xae\x10\xff\x8e\xed$ݴ+q\x8a\xed\x99\xf7f\xe6\xcd\v{\xf3\xe1\xfb\xe6\xe1\xe7\xfdG\xe8\xe8h\x9a\x05\x9b>\x8a\xcbf\x01\xc0\x8e\x8a8\x88\x8e\x87\xa8h]\xfdxخ" +
			"\xdeW\xcd\"GH\x93Q\xcdf\xbb\xdb}\x83\x15\xec\x04\xb7\f\x87\xb7\x1c5\xda>A\x17\xd4~\xbdD\x14\xd2>\xc6Z\x18\xd7˽\xe1A\xd5\xc2\x1d\x91?\xf2\x13\x1a\xddF\xa4ߚH\x85U\xeb\x1cE\n\xdc\xe3m}[\xbfC\x11#\x9e\xdfꣶuzYBPf\xbd\x8c\xf4lT\xec\x94\"\xf0\xa9\x8a\"\xd1-K\xe1\x12\xc8" +
			"'\x80\xd6\xc9g\xf8S\x8e\x00\x9eK\xa9\xedaE\xce\xdfݾ\xf5\xa7\xf2\xfc7#p\x840\x1c\xa6^\xb0\f,d\x96\xff\x02ax\x8c\xeb*\x1d[\x1e`\xf8\xac\xa4\xda\xf3\xde\xd0t\xdd듒\x99\xba\x1a*3\xa9\xcf@\xe1,qmU\x18c\x97ё W\x9ee\xa4\x1c~\x95\xd1\x06ne5HZa5\bϐ\x9fI1" +
			"\xb1\x96ͼn\xc0\x18\ue8da\x9a\x9d\xee\xf3j\xbd\x99\x95\x9b\x12\xd3g\x96S\x96:\xbf\x96&\xc7~bZ\u007f\x9d\xbdS5\x83\x13\xf8\x05\x10\xe7H\x86\xbd\xb9\xea\xfa\xe2\xc80\x15\x1e<\xf6\x1f\x19Yw3\x85<?\xa8\xb3\x82E\x97;\xd8d\xb3m\xb3ٖ\x11\xee\xbf~\x01r\xce<iJK\xbe\x19Ub\xbe\xd9)\xf52DG" +
			"\xe4\xe3\x1dbk\xdc\xe1ڬ\xdaRp\xb2\x17\xd9Ab\x1fc\x9a3\xa7\x81w\x91\xf2\xb0\xe0\xc2k\xa2\x83\xa6\xaeo\v\xfe\x85\x0eGx\x9e'\xe8\xb6'\x05\xce\xc2'M\x9f\xfb631\xf4\x83\bE\r\x86\x83\x17S\xdb\xf9\xc7\xfc\x17\x00\x00\xff\xff\xae7\xcf^\xaf\x03\x00\x00",
	},

	"/scan.html": {
		local: "cli/serve/static/scan.html",
		size:  3829,
		compressed: "" +
			"\x1f\x8b\b\x00\x00\tn\x88\x00\xff\xb4W\xffn\xdb6\x10\xfe?O\xc1hEe\xa3\x91\xb8,\xc10,\xb2\x06\xac]7\f\xc3: \x1d\x86\xa1\r\x02J\xa2,\xba\x94\xa8\x91\x94kc\xed\xbb\xefHJ\xb6$\xcbq\x8b\xa5\x02l\xf1\xc7\xdd}\xdf\x1d\x8fG*:\u007f\xf1\xea\xf9\xeb\xbf\xff\xf8\t\x15\xba\xe4\xf1YԽ(\xc9\xe23\x84\xa2" +
			"\x92j\x82҂HE\xf5\xc2\xfb\xf3\xf5\xcb\xe0;/>33\x9aiN\xe3\xe7/oo\u007fC\x01\xbaMI\x15a7ff9\xabޡB\xd2|\xe1c\x9cf\xd5J\x85)\x17M\x96s\"i\x98\x8a\x12\x93\x15\xd9`\xce\x12\x85\xf5{\xa65\x95A\"\x84VZ\x92\x1a_\x85W\xe15N\x95»\xb1\xb0dU\b#>\x92\x94/" +
			"|\xa5\xb7\x9c\xaa\x82R\x8dj@\xa1:-|\vl'L+\x11\xd9\x16\xfd\v\r\xf3\xd4$\xcbX\xb5\f\xb4\xa8\xbfGW_כ\x1b;\xf1\xd1h\xe0V%\xc2\xce\xeb\xb3ȨZc\x15Y\xa3\x94\x13\xa5\x16\x1e4\x13\"\x91{\x05\x19\xcdI\xc3u\xd7\xcdنfƸ\x17[\xbbQ\xc6v\x8a\xa9\xa84a\x15\x95\xed\xdcp\xb65" +
			"`\x90{\x12 CF\x12\x89$U湐z\xd8s\x81\x8f0\xd9\x19\xc5`ծ\xcc!\x01\xceI\xadhG\xb6\xeb\xf7\xd1\x1aރ\xeb\x04\xe1Փ\xb1\x8b\xda\xefZ\x92-\x1f\x05\xcb\x1f\x9a\xdc\xf1b\x97\td\xa0\x88\xfb\x9a\x11n\xf8\x88\xf5\xa0\x19a\x00v9\xf6@\x18\xa3ⲛ\xaaɒ\xee\"\xe8\xe0\x8b\xcb6\x14}\x13R" +
			"\xbc\x9f\\\x03\bH\xa0\xca\xe0[d\x1ae\x16\\w\r\x91\xe7\x90\xf6\xc1u?R\xb9\x90e\xa7h\xda\x01\xab ש\x87X\x06\x96r\xa5\xc0\x16P\xf0 \x88%\x1d\x8c\fCI\x12\xca\x11\x18Xx\x85Pڋ\u007f\x81\u007f\x88\x93\x19\x8eQĪ\xba\xd1\x03\x18\xe3\xbf\x14\xdc\xe1X\x95\x16\xc1\xb5kNRZ\b\x0e1hAC!\x97" +
			"\x1e\xd2\xdb\x1ad4\xdd\x00\x04\x8a\x92FkQuv\x13]!\xf8\x05\xb5d%\x91\xdbNX5I\xc9t\x17I\xa7\xd2_=C\xe7\xf8\xfa}\x99\xa8k\x92p\xdai\xba\x8e\xfd\x87\x9a!\xc1e\x9a\xb5](\x15\xac\xa6\x99\x8b\x92\xa4\n\xf6\xa8\xf2b(Lfv\xb7;\x86DjRQ\x1e,\xa5hj\xa7G\xd2\x14\xac2Q\x19͝" +
			"\u007fǒ\xb5\xf3:R)`k\xa4d\n\x1b\xe2T\xcd[\xfd\xd3P\xb9\xc5߄\x97\xe1U۱\x15ne\xe9:S\xf1ުC}2\xf3\xbf\xda'\x94?\x0f\xddR\xcd\xf2\xa6J5\xf0\x9d\xd15\xad\xf4|W\xf5\x8c|\x1b\x04\x10\xa6e\xad\xb7\xb3\xf9M7\x19.\xa9\xfe\xf5\xf6\xd5\xef3\x1f\x93\x9a\xe1\xf5%\xb6\xb6\xed^\xfe\xc1d" +
			"\xd5\xc2GϬ\r\xd3\x01\x03k\xc2g\xf3\v\xb4Cˈ&{0\x84X\x8e\xec\xd8\x1b_5iJ\xa1Vߡ\xa7O\x91\x1br<\xfc\xbb\xbe\x82!AIZ̆\"=\x88\x9c\x94\x8co\xefM\xa6_ CL\r\xf5\x11ZCQv\x8a\xf7\x90ih\x81\xfcH\xcbؿ\x19\b\xf5\x04\x9eY\x89,6\xbe\xf5\xacCϏ\xdeb" +
			"3qR\xf5\xb3\xb3ql\xb3\xf5\xda\xfa\xd3s\xd6\xf4\xa1\xc0\xb5\xde:౻\x13\x84\xc0\xdbS\"\xceݾ\xfd\x9e\xbf#e\x13Х\x84b\n\xb1t\x86\xdex\xb6\xef\xdd\u074cD͂\xb7\xa2\v\xe4\xfd,D\xe6\x1d\xf2\x9d\x0e\xa1\x82]\xd7Epɷu\xc1\xa0\xc0\xa1]+\x10\xef\x02Ŗf\a\xbe\xc5F6F\xc6\xfc\xe4\n" +
			"\xc11\x8e(\x87\xf3mH\xe7/\"+8\xf2\x1f\x8d\x11\xdd\xc0dI\xccJ\x8d\xa9\xb5P\x9f\xc3\xeeG\xf2x\xb1\x92\xb4\x14k:&\x05\b\x0f\x13z\x1cp(]j\"&ǠOd*h\x1dl^\x97\x92\xa2\xd1\xe6H\xdc\xe5\xa4\xef\x06\xfcɤl\x85\xcf!\xd2M\x05w58\xa0\xb3O\x8c\xf6\x01x\x1f\xfeޜ\x90\xc0\xe1I" +
			"h\x1a-\xcc\xfcPcϡՀ\x15\x17Ɋ\xa6pR\u007f\xf8\x80\xc6SDJ\xb2\x9dL\x87\t\x8a\xff\xb3\xf6\xb8\xa7\xad@\x8eH\xaf\x041\x88\xd6\xe6\x02<\xe6\r\x9d\xe63]\x80\xa60\x0e\xc3p~\xc2\xd7cK\x02\xc5\xca\x12;Z\xa4\xbbg\x9c^\x0f\x9a4g_h\xc2T-Y\xbe\x9d\xb5>\x9f\x82\xf8\xb4\x8c\xb5d&\x12c" +
			"R\xdf\xdeM&L\x1cݧc+#O\x8e\xa6\xe5ax&\u061cܵc\xbf\x8ey4ilx%!uM\xabl\xb6\xb700\xfdq~6f\xb0ǶW\x9d\x10\xbe\xfd\xcc\xfb\x85\xfb\x1c\xeb.7Nj\u007f\x8d\x82[\xac\xfd\xa2\x83\xef\x02\xf3y\xfb_\x00\x00\x00\xff\xff\x06N\x9fR\xf5\x0e\x00\x00",
	},

	"/": {
		isDir: true,
		local: "cli/serve/static",
	},
}
