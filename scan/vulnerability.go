package scan

import (
	"crypto/rsa"
	"errors"
	"net"
	"net/url"
	"strings"

	"github.com/FiloSottile/Heartbleed/heartbleed"
	"github.com/cloudflare/cf-tls/tls"
	"github.com/cloudflare/cfssl/certinfo"
	"github.com/cloudflare/cfssl/helpers"
)

// Vulnerability contains scanners to detect vulnerabilities such as Heartbleed
var Vulnerability = &Family{
	Description: "Scans a host to detect TLS vulnerabilities.",
	Scanners: map[string]*Scanner{
		"Heartbleed": {
			"Scan for Heartbleed vulnerability",
			heartbleedScan,
		},
		"LogJam": {
			"Scan for LogJam vulnerability",
			logjamScan,
		},
		"FREAK": {
			"Scan for LogJam vulnerability",
			freakScan,
		},
		"WeakDH": {
			"Scan for LogJam vulnerability",
			weakdhScan,
		},
		/*"TLSPoodle": {
			"Scan for LogJam vulnerability",
			tlspoodleScan,
		},
		"Lucky13": {
			"Scan for LogJam vulnerability",
			lucky13Scan,
		},*/
	},
}

func heartbleedScan(addr, hostname string) (grade Grade, output Output, err error) {
	tgt := &heartbleed.Target{
		Service: "https",
		HostIp:  hostname,
	}

	u, err := url.Parse(tgt.HostIp)
	if err == nil && u.Host != "" {
		tgt.HostIp = u.Host
	}

	out, err := heartbleed.Heartbleed(tgt, []byte("github.com/FiloSottile/Heartbleed"), true)
	if err == heartbleed.Safe {
		grade = Good
		err = nil
	} else if err != nil {
		grade = Warning
	} else {
		output = out
	}
	return
}

// Helper to get all Ciphers with the keyword "DHE"
func allDHECiphersIDs() []uint16 {
	dheCount := 0
	for _, name := range tls.CipherSuites {
		if strings.Contains(name.Name, "_DHE_") {
			dheCount = dheCount + 1
		}
	}
	ciphers := make([]uint16, 0, dheCount)
	for cipherID, name := range tls.CipherSuites {
		if strings.Contains(name.Name, "_DHE_") {
			ciphers = append(ciphers, cipherID)
		}
	}
	return ciphers
}

func logjamScan(addr, hostname string) (grade Grade, output Output, err error) {
	// Test 1: See if server will do a DHE handshake with a DHE_EXPORT cipher
	tcpConn, err := net.Dial(Network, hostname+":443")
	if err != nil {
		return
	}

	config := defaultTLSConfig(hostname)

	// Append DHE_EXPORT ciphers
	ciphers := make([]uint16, 0, 2)
	ciphers = append(ciphers, 0X0011)
	ciphers = append(ciphers, 0X0014)
	config.CipherSuites = ciphers

	config.CurvePreferences = allCurvesIDs()
	conn := tls.Client(tcpConn, config)
	serverCipher, _, _, _, _, _ := conn.SayHello()
	conn.Close()

	// If Server accepted a DHE EXPORT cipher, then it is vulnerable.
	if serverCipher != 0 {
		grade = Bad
		err = errors.New("Error! Server accepts a DHE EXPORT cipher")
		return
	}

	// Test 2: Do a DHE handshake and look at the public exponent used by the server
	tcpConn, err = net.Dial(Network, hostname+":443")
	if err != nil {
		return
	}

	config = defaultTLSConfig(hostname)
	config.CipherSuites = allDHECiphersIDs()
	config.CurvePreferences = allCurvesIDs()
	conn = tls.Client(tcpConn, config)
	serverCipher, _, _, _, _, _ = conn.SayHello()
	conn.Close()

	// If Server uses a DHE cipher with a public exponent <= 1024 bits, then it's vulnerable
	if serverCipher != 0 {
		certData, err := certinfo.ParseCertificateDomain(hostname)
		if err != nil {
			grade = Bad
			return grade, output, err
		}

		ca, err := helpers.ParseCertificatePEM([]byte(certData.RawPEM))
		if err != nil {
			grade = Bad
			return grade, output, err
		}

		// TODO: this public key isn't from the DHE handshake
		// Not sure how to get that key...
		pub, _ := ca.PublicKey.(*rsa.PublicKey)
		if pub.N.BitLen() < 1024 {
			grade = Bad
			err = errors.New("Unsupported public key length")
			return grade, output, err
		}
	}

	grade = Good
	return
}

func weakdhScan(addr, hostname string) (grade Grade, output Output, err error) {
	// DHE handshake
	tcpConn, err := net.Dial(Network, hostname+":443")
	if err != nil {
		return
	}
	config := defaultTLSConfig(hostname)
	config.CipherSuites = allDHECiphersIDs()
	config.CurvePreferences = allCurvesIDs()
	conn := tls.Client(tcpConn, config)
	conn.SayHello()
	conn.Close()

	err = errors.New("WIP")

	// Look for Apache and other web servers' default primes
	// Check DH param used in DHE against a set of standard ones shipped with web servers like Apache
	// ???
	return
}

// Helper to get all export grade ciphers
func allExportCiphersIDs() []uint16 {
	exportCount := 0
	for _, name := range tls.CipherSuites {
		if strings.Contains(name.Name, "_EXPORT_") {
			exportCount = exportCount + 1
		}
	}
	ciphers := make([]uint16, 0, exportCount)

	for cipherID, name := range tls.CipherSuites {
		if strings.Contains(name.Name, "_EXPORT_") {
			ciphers = append(ciphers, cipherID)
		}
	}
	return ciphers
}

func freakScan(addr, hostname string) (grade Grade, output Output, err error) {
	// See if the server will negotiate a EXPORT grade cipher
	tcpConn, err := net.Dial(Network, hostname+":443")
	if err != nil {
		return
	}
	config := defaultTLSConfig(hostname)

	// Append EXPORT ciphers
	config.CipherSuites = allExportCiphersIDs()
	config.CurvePreferences = allCurvesIDs()
	conn := tls.Client(tcpConn, config)
	serverCipher, _, _, _, _, _ := conn.SayHello()
	conn.Close()

	// If Server accepted an EXPORT cipher, then it is vulnerable.
	if serverCipher != 0 {
		grade = Bad
		err = errors.New("Error! Server accepts a EXPORT cipher")
		return
	}
	grade = Good
	return
}

/*func tlspoodleScan(addr, hostname string) (grade Grade, output Output, err error) {
}

func lucky13Scan(addr, hostname string) (grade Grade, output Output, err error) {
}*/
